# Introduction to R and Bioconductor

## R basics

### Basic operations

R as a glorified calculator. Try typing this in directly into the console. Then start typing this into the editor, and save your script. Use the run button, or press `CMD`+`Enter` (`Ctrl`+`Enter` on Windows).

```{r, results='hide'}
2+2
5*4
2^3
```

R Knows order of operations.

```{r, results='hide'}
2+3*4
```

### Functions

R has built-in functions.

```{r, results='hide'}
# Notice that this is a comment. 
# Anything behind a # is "commented out" and is not run.
sqrt(144)
log(1000)
```

Get help by typing a question mark in front of the function's name:

```
?log
```

Note syntax highlighting when typing this into the editor. Also note how we pass *arguments* to functions. Finally, see how you can *next* one function inside of another (here taking the square root of the log-base-10 of 1000).

```{r, results='hide'}
log(1000)
log(1000, base=10)
sqrt(log(1000, base=10))
```

### Vectors

Let's create some numeric vectors. Vectors (aka "arrays" in Perl, "lists" in Python) are single *objects* containing an ordered collection of *elements*. A simple vector is a numeric vector, a single *object* containing several numbers. Here let's display a few vectors. We can also do vector arithmetic. When printing vectors to the screen that have lots of elements, notice that the bracketed number in the gutter of the output is just a counter indexing the number of elements in the vector.

```{r, eval=FALSE}
# Some simple numeric vectors:
1:5
6:10
1:5 + 6:10  
1:100 

# Get some help with the seq() function, then create a vector from 2 to 200 by 2s.
# Notice how the seq() function works -- the `to` argument will never be exceeded.
?seq
seq(from=2, to=200, by=4)
```

### Variables / objects

You can store values in a variable or object. Use the `<-` operator for assignment. `=` also will work, but `<-` is conventional and preferred. Objects should start with a letter and can include numbers and underscores. Named variables are objects containing whatever is assigned to them. Remember, *everything is an object*.

```{r, results='hide'}
x <- 5
x

y <- 42
y

y-x
z <- y-x
z

x <- 1:5
y <- 6:10
x
y
x+y
x*y
x^y
```

You can see what objects (variables) are stored by viewing the Environment tab in Rstudio. You can also use the `ls()` function. You can remove objects (variables) with the `rm()` function. You can do this one at a time or remove several objects at once.

```{r, results='hide'}
ls()
rm(x)
ls()
x # oops! you should get an error because x no longer exists!
rm(y,z)
```

### Classes: everything is an object

Use the `class()` function to see what *kind* of object a something is. You can run `class()` on constants, built-in objects, or objects you create. Let's create a character object and then get it's class. 

```{r, results='hide'}
class(42)
class(log)
name <- "Stephen"
name
class(name)
```

Certain *functions* operate only on certain *classes* of object. Here, `name` is a `character` class, assigned to `"Stephen"`. The built-in `toupper()` function will operate on character objects, but not others. 

```{r}
toupper(name) # name is an object of class character. methods or functions are associated with certain classes.
toupper(log) # can't run a function that expects character on an object of class function
```

We can combine values into a vector with the built-in `c()` function.

```{r, results='hide'}
# Get some help with ?c
x <- c(1,3,5)
x
class(x)
length(x)
```

Let's create and manipulate a character vector:

```{r, results='hide'}
y <- c("My", "name", "is", "Stephen")
y
class(y)
length(y)
y <- c(y, "Turner")
y
length(y)
```

Try running the built-in `sum()` function on a numeric vector:

```{r, results='hide'}
sum(x)
```

Combining characters with numerics results in coercing everything to be a character class. 

```{r, results='hide'}
y
z <- c(x,y)
z 
class(z)
```

Certain functions only operate on certain classes. You can't compute the `sum()` of a character vector!

```{r}
z
sum(z)
```

### Slicing/indexing vectors

Let's create a vector of 50 integers going from 101 to 150. We can access certain elements of that vector by putting the element's *index(es)* in square brackets. E.g., `x[1]` will return the first element in vector `x`. Calling `x[c(3,5)]` will access the third and fifth elements. Calling `x[1:10]` will return the first ten elements of `x`. 

*Special note: R indexes vectors starting at 1. This is different from many other languages, including Perl and Python, which index starting from zero.*

```{r, results='hide'}
# Create the vector.
x <- 101:150

# Get the first element.
x[1]

# Get the 42nd element.
x[42]

# Get the 20th through the 25th elements. 
x[20:25]

# If you try to access elements that don't exist, you'll return missing values.
# Missing values are represented as NA
x[45:55] #NA is missing value!
```

### Data Frames

Data frames are a standard way to store heterogeneous tabular data in R: tabular, meaning that individuals or observations are typically represented in rows, while variables or features are represented as columns; heterogeneous, meaning that columns/features/variables can be different classes (on variable, e.g. age, can be numeric, while another, e.g., cause of death, can be text).

Later on we'll go over how we load our own data, but for now, let's use a built-in data frame called `mtcars`. This data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973â€“74 models). We can load this built-in data with `data(mtcars)`. By the way, running `data()` without any arguments will list all the available built-in datasets included with R.

Let's load the data first. Type the name of the object itself (`mtcars`) to view the entire data frame. *Note: doing this with large data frames can cause you trouble.*

```{r, results='hide'}
data(mtcars)
class(mtcars)
mtcars
```

There are several built-in functions that are useful for working with data frames.
* `head()` prints the first few lines of a large data frame.
* `length()` tells you the number of features (variables, columns) in a data frame.
* `dim()` returns a two-element vector containing the number of rows and the number of columns in a data frame.
* `str()` displays the structure of a data frame, printing out details and a preview of every column.
* `summary()` works differently depending on what kind of object you pass to it. Passing a data frame to the `summary()` function prints out some summary statistics about each column (min, max, median, mean, etc.)

```{r, results='hide'}
head(mtcars)
length(mtcars)
dim(mtcars)
dim(mtcars)[1] # number of rows (individual cars in the survey)
dim(mtcars)[2] # number of columns (number of variables measured)
str(mtcars)
```

We can access individual variables within a data frame using the `$` operator, e.g., `mydataframe$specificVariable`. Let's print out the number of cylinders for every car, and calculate the average miles per gallon for ever car in the dataset (using the built-in `mean()` function).

```{r, results='hide'}
# display the number of cylinders for each car. 
mtcars$cyl
# first display MPG for all vehicles, then calculate the average.
mtcars$mpg
mean(mtcars$mpg)
```

We can also access certain rows or columns of a dataset by providing multiple indices using the syntax `mydataframe[rows, columns]`. Let's get the first 4 rows and the first two rows (MPG and # cylinders) from the dataset:

```{r, results='hide'}
head(mtcars)
mtcars[1:4, 1:2]
```

We can also use the `subset()` function to return a subset of the data frame that meets a specific condition. The first argument is the data frame you want to subset. The second argument is a condition you must satisfy. If you want to satisfy *all* of multiple conditions, you can use the "and" operator, `&`. The "or" operator `|` (the pipe character, usually shift-backslash) will return a subset that meet *any* of the conditions. 

The commands below will:

0. Return only cars with 6 cylinder engines.
0. Return only cars with greater than 6 cylinders.
0. Return only the cars that get at least 20 miles per gallon or have a displacement volume of less than 100cc.
0. Return cars with 6 cylinder engines, but using the `select=` argument, only the MPG and displacement columns. Note the syntax there -- we're passing a vector of variables created with the `c()` function to the `select=` argument, which only returns certain columns. 
0. Return cars that have greater than or equal to 6 cylinders *and* get at least 15 miles per gallon, but display only the MPG, cylinders, and qsec columns (qsec is the 1/4 mile time).

Try some subsetting on your own.

```{r, results='hide'}
subset(mtcars, cyl==6)
subset(mtcars, cyl>6)
subset(mtcars, mpg>=20 | disp<100)
subset(mtcars, cyl==6, select=c(mpg, disp))
subset(mtcars, cyl>=6 & mpg>=15, select=c(mpg, cyl, qsec))
```

The `with()` function is particularly helpful. Let's say you wanted to compute some (senseless) value by computing the MPG times the number of cylinders divided by the car's displacement. You could access the dataset's variables using the `$` notation, or you could use `with()` to temporarily *attach* the data frame, and call the variables directly. The first argument to `with()` is the name of the data frame, and the second argument is all the stuff you'd like to do with the particular features in that data frame.

Try typing the following commands:

```{r, results='hide'}
# Display the number of cylinders.
mtcars$cyl
with(mtcars, cyl)

# Compute the senseless value described above. Both return the same results.
mtcars$mpg * mtcars$cyl / mtcars$disp
with(mtcars, mpg*cyl/disp)
```

### Plotting

Plotting a single numeric variable goes down the rows and plots a value on the y-axis for each observation (index) in the data frame. 

```{r}
plot(mtcars$mpg)
```

This isn't a very useful figure. More appropriate might be a histogram. We can try to let R decide how many breaks to insert in the histogram, or we can set that manually. We can also set the color of the bars. 


```{r}
hist(mtcars$mpg)
hist(mtcars$mpg, breaks=10)
hist(mtcars$mpg, breaks=10, col="black")
```

We can create a scatterplot between two variables with `plot(varX, varY)`.

```{r}
# This would also work, but let's use with().
# plot(mtcars$disp, mtcars$mpg)
with(mtcars, plot(disp, mpg))
```

There are hundreds of plotting parameters you can use to make your plot look exactly like you want. Let's use a solid-filled point instead of an open circle with the `pch=` argument, color the points red with the `col=` argument, give it a title by passing a character object to the `main=` argument, and change the x and y axis titles with the `xlab=` and `ylab=` arguments, respectively. Let's go through this one step at a time. 

```{r}
with(mtcars, plot(disp, mpg, pch=16))
with(mtcars, plot(disp, mpg, pch=16,  col="red"))
with(mtcars, plot(disp, mpg, pch=16,  col="red", main="MPG vs Displacement"))
with(mtcars, plot(disp, mpg, pch=16,  col="red", main="MPG vs Displacement", 
                  ylab="Fuel Economy (MPG)", xlab="Displacement (cu. in.)"))
```

Notice how on that last line I broke the command up into two lines for better readability. I broke the command at the comma separating arguments, and indented the following line for readability.

On your own, try plotting horsepower vs displacement for vehicles with more than 4 cylinders. Give the graph a title and label the axes. Make the points solid (hint, `pch=16`) blue (hint, `col="blue"`) circles. Your plot should look something like this:

```{r, echo=FALSE}
with(subset(mtcars, cyl>4), plot(disp, hp, pch=16, col="blue",
                                 xlab="Displacement (cu. in.)", ylab="Gross Horsepower", 
                                 main="Horsepower vs Displacement for 6 and 8-cylinder vehicles"))
```

### Reading in / writing out data

First, lets create a small dataset consisting of only 8 cylinder cars. 

```{r, results='hide'}
mtcars_8cyl <- subset(mtcars, cyl==8)
mtcars_8cyl
```

Next, check what your working directory is with `getwd()` with no arguments, and look up some help for `write.table()` and `write.csv()`. 

```{r, eval=FALSE}
getwd()
?write.table
?write.csv
```

Using RStudio, go to the Session menu, and select the directory (folder) you want to work from under the "Set Working Directory" menu. You can also do this manually with the `setwd()` command. 

```{r, eval=FALSE}
getwd()
setwd("/Users/sdt5z/Desktop/R")
```

Once you've set your working directory either using RStudio or on the command line, save the new reduced data frame to a comma-separated file called `cars8.csv` using the `write.csv()` function. 

```{r, eval=FALSE}
write.csv(mtcars_8cyl, file="cars8.csv")
```

Data can be loaded using the Tools -- Import Dataset -- From text file menu in R studio. Or you can also load a dataset manually using `read.table()` or `read.csv()`. Here let's remove the dataset, and re-import it into an object called cars8 from the file we just saved.

```{r, eval=FALSE}
rm(mtcars_8cyl)
mtcars_8cyl
?read.table
cars8 <- read.table(file="cars8.csv", header=TRUE, sep=",", row.names=1)
cars8
rm(cars8)
cars8 <- read.csv(file="cars8.csv", header=TRUE, row.names=1)
cars8
```

## Using R+Bioconductor for gene expression analysis

In this section we'll analyze some publicly available gene expression data using R and bioinformatics-focused R packages in [Bioconductor](http://bioconductor.org/). But first, a bit about R *packages*. 

### Packages



```{r, eval=FALSE, echo=FALSE}
# BioC --------------------------------------------------------------------

## http://www.bioconductor.org/packages/2.11/bioc/vignettes/SPIA/inst/doc/SPIA.pdf
## Download data from http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE4107
## http://people.virginia.edu/~sdt5z/GSE4107_RAW.zip
## Extract tar file, gunzip all the .CEL.gz files

# Do this in folder on desktop
setwd("~/R")

biocLite(c("affy", "AnnotationDbi", "hgu133plus2cdf", "hgu133plus2.db", "genefilter", "DBI", "annotate", "arrayQualityMetrics", "limma", "GOstats", "Category", "GO.db", "KEGG.db")

?list.celfiles
library(affy)
?list.celfiles
list.celfiles("GSE4107_RAW", full.names=T)
myfiles <- list.celfiles("GSE4107_RAW", full.names=T)

?ReadAffy
myaffybatch <- ReadAffy(filenames=myfiles)
myaffybatch
class(myaffybatch)
?"AffyBatch-class"

?rma
eset <- rma(myaffybatch)
class(eset)
str(eset)
?"ExpressionSet-class"
head(exprs(eset))
dim(exprs(eset))

## Annotate the samples
pData(eset)
class(pData(eset))
pData(eset)$condition
rep("cancer", 12)
rep("healthy", 10)
c(rep("cancer", 12), rep("healthy", 10))
factor(c(rep("cancer", 12), rep("healthy", 10)))
pData(eset)$condition <- factor(c(rep("cancer", 12), rep("healthy", 10)))
pData(eset)


# filter the dataset
library(genefilter)
eset
?featureFilter
eset <- featureFilter(eset, require.entrez=T, remove.dupEntrez=T, feature.exclude="^AFFX")
eset

## Annotate the features
fData(eset)
annotation(eset)
library(annotate)
library(hgu133plus2.db)
ls("package:hgu133plus2.db")
ID     <- featureNames(eset)
class(ID)
head(ID)
head(exprs(eset))
?lookUp
#trust me on this one
Symbol <- as.character(lookUp(ID, "hgu133plus2.db", "SYMBOL"))
Name   <- as.character(lookUp(ID, "hgu133plus2.db", "GENENAME"))
Entrez <- as.character(lookUp(ID, "hgu133plus2.db", "ENTREZID"))
tmp <- data.frame(ID=ID, Entrez=Entrez, Symbol=Symbol, Name=Name, stringsAsFactors=F)
head(tmp)
fData(eset) <- tmp
head(fData(eset))
rm(ID, Symbol, Name, Entrez, tmp)

# Quality Assessment ------------------------------------------------------

# Load the arrayQualityMetrics package
library(arrayQualityMetrics)

# Run arrayQualityMetrics on your eset, giving it the name of an ouput directory.
# intgroup is the name of the sample covariate(s) used to draw a colour side bar next to the heatmap. character matching column in pData(eset)
# also give it a title
?arrayQualityMetrics
arrayQualityMetrics(eset, outdir="aqm", intgroup="condition", reporttitle="Quality Assessment Report")
# Now go open the current working directory, and open aqm/index.html in your browser


# Data Analysis -----------------------------------------------------------

## The limma package will be used for analysis
library(limma)

## Make the design and contrasts matrix
pData(eset)
design <- model.matrix(~0+condition, data=pData(eset))
design
class(design)
colnames(design)
colnames(design) <- c("cancer", "healthy")
design
colnames(design) <- sub("condition", "", colnames(design))
design

## make contrast matrix
contrast.matrix <- makeContrasts(cancer_v_healthy=cancer-healthy, levels=design)
contrast.matrix

## Fit model
fit <- lmFit(eset,design)
fit <- contrasts.fit(fit, contrast.matrix)
fit <- eBayes(fit)
class(fit)

## Get statistics from that model fit
topTable(fit)
?topTable
nrow(fit)
tt <- topTable(fit, number=nrow(fit))

head(tt)
class(tt)
dim(tt)

## First, write the entire results table to a csv file and open in Excel
## Assignment: how many genes are significant at an adjusted p-value of 0.005?
## Write this table to a CSV file and open it in excel
write.csv(tt, file="diffexpr-all.csv")
sig <- subset(tt, adj.P.Val<0.005)
dim(sig)
write.csv(sig, file="diffexpr-significant.csv")

## volcano plot
with(tt, plot(logFC, -log10(adj.P.Val), pch=16, col="black"))

## heatmap
heatmap(exprs(eset[featureNames(eset) %in% sig$ID, ]))

library(GOstats)
library(Category)
?hyperGTest
?"GOHyperGParams-class"
myuniverse <- tt$Entrez
mysiggenes <- sig$Entrez
myanno <- annotation(eset)

?"KEGGHyperGParams-class"
library(KEGG.db)
KEGGparams <- new("KEGGHyperGParams", geneIds=mysiggenes, universeGeneIds=myuniverse, annotation=myanno, testDirection="over", pvalueCutoff=.05)
KEGGres <- hyperGTest(KEGGparams)
KEGGres
class(KEGGres)
?"KEGGHyperGResult-class"
?"HyperGResult-accessors"
summary(KEGGres)
htmlReport(KEGGres, file="KEGG report.html")

?"GOHyperGParams-class"
library(GO.db)
GOparams <- new("GOHyperGParams", geneIds=mysiggenes, universeGeneIds=myuniverse, annotation=myanno, conditional=TRUE, ontology="MF")
GOres <- hyperGTest(GOparams)
htmlReport(GOres, file="GO MF terms.html")
```